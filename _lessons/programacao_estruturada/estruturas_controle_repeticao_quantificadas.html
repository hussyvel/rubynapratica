---
title: Estruturas de Controle de Repetição Quantificadas
slug: estruturas_controle_repeticao_quantificadas
author: Jalerson Lima
layout: content
unit: programacao_estruturada
order: 8
comments: true
---

# Aula 08 - Estruturas de Controle de Repetição Quantificadas

## Introdução

Para ilustrar a utilidade das estruturas de controle de repetição quantificadas, também conhecidas como laços, iremos usar o exercício proposto na [Atividade 8.1](#aula08-atividade01). Tente resolver esse exercício com os conhecimentos que você já possui.

{#aula08-atividade01}
X> ## Atividade 8.1
X>
X> Crie um _script_ em Ruby que lê um número inteiro e mostra a tabuada de multiplicação desse número de 1 a 10.

Para resolver o problema proposto na [Atividade 8.1](#aula08-atividade01), provavelmente você produziu um _script_ parecido com o ilustrado no [Exemplo de código 01](#aula08-codigo01).

{#aula08-codigo01}
<<[Exemplo de código 01 - Solução da Atividade 8.1](code/exemplo81.rb)

Observe que, para resolver esse problema usando apenas os conhecimentos que temos atualmente, precisamos escrever repetidas vezes uma ação específica: multiplicar o número informado pelo usuário por um outro número (linhas 4 a 13). Para esse problema específico, precisamos realizar essa ação apenas 10 vezes, mas e se o problema exigisse que executássemos a ação 100 vezes? Ou 1000 vezes? Iríamos escrever a mesma linha de código várias vezes? E pior: o problema pode exigir que a ação seja executada um número variável de vezes.

Para resolver problemas como esse, em que ações precisam ser feitas repetidas vezes, é que devemos utilizar as estruturas de controle de repetição quantificadas. Essas estruturas são ditas quantificadas porque elas executam um número determinado de vezes.

## Estruturas de controle de repetição quantificadas em Ruby

A linguagem Ruby possui três estruturas de controle de repetição quantificadas: o `for`, o `each` e o `times`.

### Estrutura de repetição: `for`

O `for` (para) é uma estrutura de repetição muito comum e presente em quase todas as linguagens de programação. O [Exemplo de código 02](#aula08-codigo02) ilustra a sintaxe do `for`.

{#aula08-codigo02}
<<[Exemplo de código 02 - Sintaxe do `for`](code/exemplo82.rb)

O [Exemplo de código 03](#aula08-codigo03) ilustra um exemplo de uso do `for`.

{#aula08-codigo03}
<<[Exemplo de código 03 - Sintaxe do `for`](code/exemplo83.rb)

Conforme explicamos anteriormente, o `for` é uma estrutura de repetição que executa um trecho de código várias vezes. Cada execução do `for` é chamada de iteração. Portanto dizemos que um `for` que executa 10 vezes possui 10 iterações. Observe, no [Exemplo de código 03](#aula08-codigo03), que declaramos a variável `i`. Essa variável só existe dentro do `for` e ela assume um valor entre 1 e 10 a cada iteração. Na primeira execução do `for`, o valor de `i` é 1; na segunda execução do `for`, o valor de `i` é 2; na terceira execução do `for`, o valor de `i` é 3, e assim sucessivamente. O último valor que a variável `i` vai receber é 10.

Ao executar o código apresentado no [Exemplo de código 03](#aula08-codigo03), você deverá observar o resultado abaixo.

{lang=text}
    O valor de i é 1
    O valor de i é 2
    O valor de i é 3
    O valor de i é 4
    O valor de i é 5
    O valor de i é 6
    O valor de i é 7
    O valor de i é 8
    O valor de i é 9
    O valor de i é 10

Observe que o trecho de código dentro do `for` foi executado 10 vezes, e a cada iteração foi apresentado o valor da variável `i`.

{#aula08-atividade02}
X> ## Atividade 8.2
X>
X> Resolva o problema proposto na [Atividade 8.1](#aula08-atividade01) utilizando o `for`.

O [Exemplo de código 04](#aula08-codigo04) ilustra uma solução para o problema proposto na [Atividade 8.2](#aula08-atividade02).

{#aula08-codigo04}
<<[Exemplo de código 04 - Solução do problema proposto na Atividade 8.2](code/exemplo84.rb)

Observe, no [Exemplo de código 04](#aula08-codigo04), que a linha de código que se repetia no [Exemplo de código 01](#aula08-codigo01) foi usada apenas uma vez dentro do `for`. O `for` vai se encarregar de executar o que está dentro dele 10 vezes, conforme o intervalo definido na linha 4 (`1..10`).

{#aula08-atividade03}
X> ## Atividade 8.3
X>
X> Crie um _script_ em Ruby que leia um número inteiro X e mostre os números pares entre 1 e X.

### Estrutura de repetição: `each`

O `each` (cada) é uma estrutura de repetição muito parecida com o `for`, contudo, existem duas formas de se escrever o `each`, apresentadas no [Exemplo de código 05](#aula08-codigo05) e no [Exemplo de código 06](#aula08-codigo06).

{#aula08-codigo05}
<<[Exemplo de código 05 - Sintaxe da estrutura de repetição each](code/exemplo85.rb)

{#aula08-codigo06}
<<[Exemplo de código 06 - Sintaxe da estrutura de repetição each](code/exemplo86.rb)

Não há diferença de comportamento entre as duas formas de construir o `each`, portanto, escolha aquela que preferir. O [Exemplo de código 07](#aula08-codigo07) ilustra um exemplo de uso do `each`: uma contagem de 1 a 10.

{#aula08-codigo07}
<<[Exemplo de código 07 - Exemplo de uso do each](code/exemplo87.rb)

Ao executar o [Exemplo de código 07](#aula08-codigo07), você vai observar uma contagem de 1 a 10, pois esse foi o intervalo definido na linha 1 (`1..10`). O [Exemplo de código 08](#aula08-codigo08) ilustra uma solução da [Atividade 8.1](#aula08-atividade01) usando o `each`.

{#aula08-codigo08}
<<[Exemplo de código 08 - Solução da Atividade 8.1 usando o each](code/exemplo88.rb)

Observe que, novamente, não há repetição de linhas de código, pois o `each` vai se encarregar de executar a linha 5 repetidamente (10 vezes).

{#aula08-atividade04}
X> ## Atividade 8.4
X>
X> Crie um _script_ em Ruby que leia um número inteiro X e mostre todos os números entre 1 e X que são divisíveis por 3 ou por 5.

### Estrutura de repetição: `times`

Na realidade, o `times` (vezes) não é uma estrutura de controle de repetição, mas sim um método da classe Integer, conforme vamos estudar mais à frente, quando estivermos aprendendo sobre Programação Orientada a Objetos. Contudo, o método `times` também é muito utilizado para executar trechos de código repetidamente. Assim como o `each`, também existem duas formas de se construir o `times`. Observe a sintaxe do times no [Exemplo de código 09](#aula08-codigo09) e no [Exemplo de código 10](#aula09-codigo10).

{#aula08-codigo09}
<<[Exemplo de código 09 - Sintaxe do times](code/exemplo89.rb)

{#aula08-codigo10}
<<[Exemplo de código 10 - Sintaxe do times](code/exemplo810.rb)

Uma diferença entre as duas formas de construir o `times` é que a primeira forma, ilustrada no [Exemplo de código 09](#aula08-codigo09), dispensa o uso de uma variável auxiliar. Para ilustrar o exemplo da contagem usando o `times`, observe o [Exemplo de código 11](#aula08-codigo11).

{#aula08-codigo11}
<<[Exemplo de código 11 - Exemplo de uso do times](code/exemplo811.rb)

Ao executar o [Exemplo de código 11](#aula08-codigo11), você deverá observar o seguinte resultado.

{lang=text}
    O valor de i é 0
    O valor de i é 1
    O valor de i é 2
    O valor de i é 3
    O valor de i é 4
    O valor de i é 5
    O valor de i é 6
    O valor de i é 7
    O valor de i é 8
    O valor de i é 9

Observe que, diferentemente das estruturas `for` e `each`, o `times` iniciou o valor da variável auxiliar em 0 (zero). Isso ocorre porque, no `for` e no `each`, nós podemos configurar o valor inicial e final da variável auxiliar, contudo não podemos fazer o mesmo no `times`. A variável auxiliar do `times` sempre irá começar com o valor 0 (zero).

O [Exemplo de código 12](#aula08-codigo12) ilustra uma solução da [Atividade 8.1](#aula08-atividade01) usando o `times`.

{#aula08-codigo12}
<<[Exemplo de código 12 - Solução da Atividade 8.1 usando times](code/exemplo812.rb)

Observe, na linha 4, que precisamos usar `11.times` para que o valor da variável auxiliar varie entre 0 e 10. Ao executar o [Exemplo de código 12](#aula08-codigo12), você deverá observar algo parecido com o seguinte.

{lang=text}
    Digite um número:
    2
    2 x 0 = 0
    2 x 1 = 2
    2 x 2 = 4
    2 x 3 = 6
    2 x 4 = 8
    2 x 5 = 10
    2 x 6 = 12
    2 x 7 = 14
    2 x 8 = 16
    2 x 9 = 18
    2 x 10 = 20

## Controlando a Execução de Laços

As execuções dos laços podem ser controladas através dos comandos `break`, `next` e `redo`. Cada uma tem uma utilidade específica para controle de execução das estruturas de repetição, conforme será apresentado a seguir (RANGEL, 2014).

### O comando `break`

O comando `break` (quebrar/romper) interrompe a execução do laço. O [Exemplo de código 13](#aula08-codigo13) ilustra um exemplo de uso do comando `break`.

{#aula08-codigo13}
<<[Exemplo de código 13 - Exemplo de uso do break](code/exemplo813.rb)

Observe, no [Exemplo de código 13](#aula08-codigo13), que o `each` está configurado para executar 10 vezes. Dentro do `each` há um `if` para verificar se o valor da variável `i` é igual a 7. Se for, o `break` é executado, interrompendo a execução do `each`. O resultado da execução do [Exemplo de código 13](#aula08-codigo13) é apresentado abaixo.

{lang=text}
    O valor de i é 1
    O valor de i é 2
    O valor de i é 3
    O valor de i é 4
    O valor de i é 5
    O valor de i é 6

Observe que o laço é executado 6 vezes. Na 7ª execução do laço, na qual o valor de `i` é 7, a execução é interrompida com a execução do `break`. Vale salientar que, se houverem dois laços aninhados (um laço dentro do outro), o `break` irá interromper apenas a execução do laço interno. Observe o [Exemplo de código 14](#aula08-codigo14), que ilustra esse cenário.

{#aula08-codigo14}
<<[Exemplo de código 14 - Exemplo de uso do break](code/exemplo814.rb)

O código apresentado no [Exemplo de código 14](#aula08-codigo14) possui dois `for`, um externo (no qual a variável auxiliar é `i`) e um interno (no qual a variável auxiliar é `j`). Quando o `break` for executado na linha 6, ele irá interromper apenas a execução do for interno, mas não do externo.

### O comando `next`

O comando `next` (próximo) é usado para pular a execução de uma iteração. O [Exemplo de código 15](#aula08-codigo15) ilustra um exemplo de uso do comando `next`.

{#aula08-codigo15}
<<[Exemplo de código 15 - Exemplo de uso do next](code/exemplo815.rb)

Observe, no [Exemplo de código 15](#aula08-codigo15), que o `for` está configurado para executar 10 vezes. Na 7ª iteração, na qual o valor de `i` é 7, o comando `next` é executado, interrompendo a execução da 7ª iteração e pulando para a próxima. Abaixo é apresentado o resultado da execução do [Exemplo de código 15](#aula08-codigo15). Observe a ausência do "O valor de i é 7".

{lang=text}
    O valor de i é 1
    O valor de i é 2
    O valor de i é 3
    O valor de i é 4
    O valor de i é 5
    O valor de i é 6
    O valor de i é 8
    O valor de i é 9
    O valor de i é 10

Vale salientar que, quando o comando `next` é executado dentro de um laço aninhado (um laço dentro de outro), ele irá pular a iteração apenas do laço interno, assim como ocorre com o `break`.

### O comando `redo`

O comando `redo` (refazer) reexecuta a iteração atual. Observe o comportamento do `redo` no [Exemplo de código 16](#aula08-codigo16).

{#aula08-codigo16}
<<[Exemplo de código 16 - Exemplo de uso do redo](code/exemplo816.rb)

O `for` está configurado para executar 10 vezes (linha 1). Contudo, quando o valor de `i` for igual a 3, o `redo` será executado (linha 4). Isso fará com que a 3ª iteração seja executada infinitamente. Isso é chamado de _loop_ infinito: um laço que nunca para de executar. Portanto, ao executar o [Exemplo de código 16](#aula08-codigo16), não espere a execução terminar, apenas feche a janela. Abaixo é apresentado o resultado da execução do [Exemplo de código 16](#aula08-codigo16).

{lang=text}
    O valor de i é 1
    O valor de i é 2
    O valor de i é 3
    O valor de i é 3
    O valor de i é 3
    O valor de i é 3
    O valor de i é 3
    O valor de i é 3
    ...

Observe que as duas iterações são executadas normalmente, e ao chegar na 3ª iteração, o laço `for` fica preso num _loop_ infinito.

## Exercícios

1) Faça um _script_ em Ruby que leia um número n e mostre a tabuada de multiplicação de 1 a 10 deste número.

2) Faça um _script_ em Ruby que mostre os números pares entre 1 e 100.

3) Faça um _script_ em Ruby que mostre o somatório dos números pares entre 1 e N, onde N é um valor definido pelo usuário.

4) Desenvolva um _script_ em Ruby que mostre todos os números entre 1 e 200 que são divisíveis por 3 ou por 5.

5) Desenvolva um _script_ em Ruby que leia n números (o número n deve informado pelo usuário), e diga quantos são pares e quantos são ímpares. Imprima também a soma dos números pares, e a soma dos números ímpares.

6) Desenvolva um _script_ em Ruby que, dados 2 números inteiros X e Y, calcule o valor de XY. Faça isso sem usar o operador de potenciação (**).

7) Faça um _script_ em Ruby que calcule o fatorial de um número inteiro dado pelo usuário. O fatorial de um número é calculado através da multiplicação do próprio número pelos seus antecessores. Exemplo: o fatorial de 4 é 4 x 3 x 2 x 1 = 24.

8) Um número é primo se os únicos divisores dele são 1 e o próprio número. Faça um _script_ em Ruby para ler um número inteiro positivo e determinar se ele é ou não um número primo.

9) No dia da estreia do filme “O Senhor dos Anéis”, uma grande emissora de TV realizou uma pesquisa logo após o encerramento do filme. Cada espectador respondeu a um questionário no qual constava sua idade e a sua opinião em relação ao filme: 3 – excelente; 2 – bom; 1 – regular. Criar um _script_ em Ruby que receba a idade e a opinião de 20 espectadores, calcule e imprima:

* A média das idades das pessoas que responderam excelente;
* A quantidade de pessoas que responderam regular;
* A percentagem de pessoas que responderam bom entre todos os espectadores analisados.

10) Crie um _script_ em Ruby que imprima todas as tabuadas de multiplicação de 1 a 10.

11) Criar um _script_ em Ruby em que o usuário entre com 2 notas (de 0 a 100) de cada aluno de uma turma de 5 alunos, e imprima:

* A média de cada aluno;
* A média da turma;
* O percentual de alunos com média maior ou igual a 60.

## Referências

POINT, T. Ruby Tutorial. Tutorials Point. 2015. Disponivel em: <http://www.tutorialspoint.com/ruby/>. Acesso em: 12 nov. 2015.

RANGEL, E. Conhecendo Ruby. [S.l.]: Leanpub, 2014.

SOUZA, L. Ruby: aprenda a programar na linguagem mais divertida. 1. ed. São Paulo: Casa do Código, 2012. v. I.
